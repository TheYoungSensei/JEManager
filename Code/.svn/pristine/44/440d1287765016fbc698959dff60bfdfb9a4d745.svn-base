package ucc;

import java.util.List;
import java.util.stream.Collectors;

import biz.Event;
import biz.EventDto;
import biz.Participation;
import biz.ParticipationDto;
import exceptions.OptimisticLockException;
import exceptions.WrongStateException;
import persistence.UnitOfWorkImpl;
import persistence.dao.ParticipationDao;

public class ParticipationUccImpl implements ParticipationUcc {

  private ParticipationDao participationDao;
  private UnitOfWorkImpl unit;

  ParticipationUccImpl(ParticipationDao participationDao, UnitOfWorkImpl unit) {
    this.participationDao = participationDao;
    this.unit = unit;
  }

  @Override
  public ParticipationDto addParticipation(ParticipationDto participation) {
    unit.startTransaction();
    Participation participationDto = (Participation) participation;
    unit.addInsert(participationDto);
    unit.commit();
    participationDto.setParticipationId(unit.getResult());
    if (participationDto.getParticipationId() == -1)
      return null;
    return participationDto;
  }

  @Override
  public List<ParticipationDto> getCurrentParticipations() {
    return participationDao.getCurrentParticipations().stream().map(p -> (ParticipationDto) p)
        .collect(Collectors.toList());
  }

  @Override
  public int countInvitedParticipation(EventDto event) {
    return participationDao.countParticipations((Event) event, INVITED);
  }

  @Override
  public int countConfirmedParticipation(EventDto event) {
    return participationDao.countParticipations((Event) event, CONFIRMED);
  }

  @Override
  public int countRefusedParticipation(EventDto event) {
    return participationDao.countParticipations((Event) event, REFUSED);
  }

  @Override
  public int countCancelledParticipation(EventDto event) {
    return participationDao.countParticipations((Event) event, CANCELLED);
  }

  @Override
  public int countInvoicedParticipation(EventDto event) {
    return participationDao.countParticipations((Event) event, INVOICED);
  }

  @Override
  public int countPaidParticipation(EventDto event) {
    return participationDao.countParticipations((Event) event, PAID);
  }

  @Override
  public int editStates(List<ParticipationDto> participations) throws WrongStateException {
    unit.startTransaction();
    for (ParticipationDto participationDto : participations) {
      Participation participation = (Participation) participationDto;
      participation.checkState();
    }
    for (ParticipationDto participationDto : participations) {
      //try {
        unit.addUpdate(participationDto);
      //} catch (FatalException fe) {
        //System.out.println("Optimistic lock détécté");
       // unit.rollBack();
       // return -1;
      //}
    }
    unit.commit();
    return 0;
  }

  @Override
  public List<ParticipationDto> getAllPartcipationFor(EventDto event) {
    return participationDao.getParticipationForState((Event) event, ALL).stream()
        .map(p -> (ParticipationDto) p).collect(Collectors.toList());
  }

  @Override
  public List<ParticipationDto> getInvitedParticipationsFor(EventDto event) {
    return participationDao.getParticipationForState((Event) event, INVITED).stream()
        .map(p -> (ParticipationDto) p).collect(Collectors.toList());
  }

  @Override
  public List<ParticipationDto> getConfirmedParticipationsFor(EventDto event) {
    return participationDao.getParticipationForState((Event) event, CONFIRMED).stream()
        .map(p -> (ParticipationDto) p).collect(Collectors.toList());
  }

  @Override
  public List<ParticipationDto> getRefusedParticipationsFor(EventDto event) {
    return participationDao.getParticipationForState((Event) event, REFUSED).stream()
        .map(p -> (ParticipationDto) p).collect(Collectors.toList());
  }

  @Override
  public List<ParticipationDto> getCancelledParticipationsFor(EventDto event) {
    return participationDao.getParticipationForState((Event) event, CANCELLED).stream()
        .map(p -> (ParticipationDto) p).collect(Collectors.toList());
  }

  @Override
  public List<ParticipationDto> getInvoicedParticipationsFor(EventDto event) {
    return participationDao.getParticipationForState((Event) event, INVOICED).stream()
        .map(p -> (ParticipationDto) p).collect(Collectors.toList());
  }

  @Override
  public List<ParticipationDto> getPaidParticipationsFor(EventDto event) {
    return participationDao.getParticipationForState((Event) event, PAID).stream()
        .map(p -> (ParticipationDto) p).collect(Collectors.toList());
  }



}
